1.节流：
    控制同一个IP地址在统一时间段内的访问频率（也可以通过用户token来实现，或者两者配合使用）
    时间段和频率写到settings配置中
    # 全局用户访问控制时间（默认10秒）
    VISIT_CONTORE_TIME = 10
    # 全局用户访问控制次数（默认限制3次）
    VISIT_CONTORE_LENGTH = 3

    1.外部文件写上一个类，建议继承默认的节流类,实现类方法allow_request进行自定义的节流规则：
        from rest_framework.throttling import BaseThrottle
        class VisitThrottle(BaseThrottle):
            def allow_request(self, request, view):
                # 获取用户IP与当前时间
                remote_addr = request._request.META.get('REMOTE_ADDR')
                c_time = time.time()
    2.继承Base类之后可以不用实现wait方法，如果要自定义，还是写上吧
        这个方法可以自定义提示信息，还需要等待多久才可以进行再次访问
        def wait(self):
            c_time = time.time()
            history = self.history[-1]
            wait_time = sys.VISIT_CONTORE_TIME - (c_time - history)
            return wait_time

2.源码流程
    1.dispatch入口
    2.封装request
    3.执行initial方法
    4.在认证、权限过后，进行节流控制
        self.perform_authentication(request)  - 认证
        self.check_permissions(request)  - 权限控制
        self.check_throttles(request)  - 节流控制
    5.check_throttles(request)方法内部执行了allow_request(request, self)方法
        所以实现节流控制需要在自定义节流控制的类中重写该方法
            throttle_durations = []
            for throttle in self.get_throttles():
                if not throttle.allow_request(request, self):
                    throttle_durations.append(throttle.wait())

3.通过源码的配置文件可以查询到全局节流配置
    # API相关配置
    REST_FRAMEWORK = {
        # 全局认证配置
        'DEFAULT_AUTHENTICATION_CLASSES': [
            'API.utils.auth.Authtication',
        ],
        # 全局权限配置
        'DEFAULT_PERMISSION_CLASSES': [
            'API.utils.permission.SVIPPermission',
        ],
        # 全局节流配置
        'DEFAULT_THRORRLE_CLASSES': [
            'API.utils.throttle.VisitThrottle'
        ],
    }

4.取消节流控制
    视图类中写上配置：
        throttle_classes = []  # 不进行节流控制

5.内置的控制频率类
    在BaseThrottle类中，实现了三个类方法：
        allow_request
        get_ident
        wait